1. gc时间过长，因为内存泄漏告知可用内存不足，从而出发full-gc，看下Xmx设置，看下代码是否有内存泄漏，开发环境压力测试，java内带的jvisualvm看可以看基本的内存增长，如果内存涨到了Xmx的极限值，内存泄漏，然后根据jprofiler，查找泄漏
2. 性能优化主要是两点 让代码产生更少的垃圾，垃圾产生的速度可预测
3. oracle jdk  6G内存CMS回收，6G以上CPU强劲的话使用G1，主要是不要出现内存泄漏，在确保代码可读性的基础上减少不必要的对象创建
4. 更多时候是需要更大的吞吐量。所以 Oracle 的 JDK 对于大部分人来说已经够用了。
5. 堆并不是越大越好，反而越大看 gc 一次时间越久 
小堆的 web 应用主要还是 CMS ，大堆可以上 G1
6. 如果你想要最小化地使用内存和并行开销，请选Serial GC；
	如果你想要最大化应用程序的吞吐量，请选Parallel GC；
	如果你想要最小化GC的中断或停顿时间，请选CMS GC
	
7. CMS是一后续最短回收停顿时间为目标的收集器，重视响应速度，希望系统停顿时间最短
	1. CMS(Concurrent Mark Sweep)基于标记-清除算法分为四个步骤
	2. 初始标记->并发标记->重新标记->并发清除
	3. 两个mark需要stw，其他不需要
	4. CMS的几个缺点
		1. 对CPU资源敏感，在并发阶段 不停顿，但会因为占用一部分线程而导致应用程序变慢，总吞吐量 会降低
		2. 无法处理浮动垃圾， 在并发 清除时 会产生浮动垃圾
		3. 基于标记清除，会产生大量空间碎片
		4. 基于二三 有两个参数 -XX  CMSInitiatingOccupanncyFraction  不易设置太高，会容易导致大量ConcurrentModeFailure , (CMSFullGCsBefireCompaction)执行多少次不压缩的fullgc 进行一次压缩的
8. G1 
	1.  G1
8. java写文件做了什么 